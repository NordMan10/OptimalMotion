Проектирование:
* Выделить метод считывания исходных данных (при изменении формата исходных данных нужно будет менять только один метод);




// ! — элемент нужно задать при создании объекта

Основные сущности: 
* Id ВС;
* Тип ВС;
* ВС; +
* Взлетающий ВС; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* Садящийся ВС;
* Спец площадка; +
* ВПП; +
* Контроллер реализуемости планового момента выхода; +
* Генератор ВС;
* Момент ВС; +
* Интервал ВС; +
* Перечисление типов моментов; +
* Перечисление типов интервалов; +
* Момент; +
* Интервал; +
* Элементы GUI: таблица (пока что таблица, дальше видно будет); +
* Не явная общая сущность (что-то вроде организующего всю работу класса); 

Содержание сущностей:

ВС: ========================================================================

Данные:
* Id;
* Тип ВС
* Моменты;
* Интервалы; 
* Флаг необходимости обработки; !
* максимум ожидания обработки; !
* константный интервал для безопасного слияния; !
* максимум ожидания на предварительном старте; !

Методы:
* Расчет момента выхода на ПРСТ: (2.1, 3.1)
	Если обработка не нужна => вызываем метод (1.1), прибавляем время движения от стоянки до ПРСТ. Возвращаем результат;
	Если обработка нужна => вызываем метод (1.2), прибавляем время движения от стоянки до спец площадки, прибавляем время обработки и время движения от спец площадки до ПРСТ. Возвращаем сумму;

* Расчет интервала ожидания на ПРСТ: (1.1)
	Вызываем метод {ВПП} рассчета ожидания на ПРСТ и возвращаем результат;

* Расчет суммы интервала ожидания обработки и интервала для безопасного слияния: (1.2)
	Вызываем метод {Спец площадки} расчета интервала ожидания обработки и интервала ожидания для безопасного слияния. Возвращаем результат;

* Расчет момента выхода на исполнительный старт: (2)
	1) Вызываем метод (2.1) если он еще не был вызван;
	2) Прибавляем к полученному/известному моменту выхода на ПРСТ интервал времени руления на исп. старт и возвращаем сумму;

* Расчет момента взлета (покидания ВПП): (3)
	1) Вызываем метод (3.1) если он еще не был вызван;
	2) Прибавляем к полученному/известному моменту выхода на ПРСТ интервал времени руления на исп. старт и интервал времени взлета. Возвращаем сумму;

* Расчет момента запуска двигателей: (1)
	Если обработка не нужна => вызываем метод (1.1), прибавляем момент появления и возвращаем сумму;
	Если обработка нужна => вызываем метод (1.2), прибавляем прибавляем момент появления и возвращаем сумму;

* Возврат момента запуска двигателей: (ИНТЕРФЕЙС)
	1) Вызываем метод (1);
	2) Сохраняем данные этого метода в нужном формате и возвращаем;

* Возврат интервала занимания {ВПП} (уже с учетом задержек, чтобы записать в {ВПП}): (ИНТЕРФЕЙС)
	1) Вызываем метод (2);
	2) Вызываем метод (3);
	3) Формируем интервал и возвращаем его;

* Возврат интервала занимания {Спец площадки} (уже с учетом задержек, чтобы записать в {Спец площадку}): (ИНТЕРФЕЙС)
	0) Если обработка не нужна — выбрасываем исключение с соответствующим сообщением;
	1) Вызываем метод (1.2) и прибавляем время движения от стоянки до спец. площадки. Получили момент прибытия;
	2) К полученному моменту прибавляем время обработки. Получили момент освобождения;
	3) Формируем интервал и возвращаем его;


=================================================================================

Перечисление типов моментов:

Типы:
* появление; !
* плановое прибытие на предварительный старт; !
* отправление (запуск двигателей);
* прибытие на предварительный старт;
* прибытие на исполнительный старт;
* покидание ВПП (взлет);


=================================================================================

Перечисление типов интервалов:

Типы:
* движение от стоянки на предварительный старт; ! (мб не задано)
* движение от стоянки до спец площадки; !
* ожидание обработки; 
* ожидание безопасного слияния;
* обработка; !
* движение от площадки к предварительному старту; !
* ожидание на предварительном старте; 
* руление на исполнительный старт; !
* взлет; !


=================================================================================

Момент:
Данные:
* тип;
* временное значение, мс;

Методы:
* Оператор сложения момента и интервала и наоборот;


=================================================================================

Интервал:
Данные:
* тип;
* начальный момент;
* конечный момент;

Методы:
* Получить значение интервала в мс между своими моментами;
* Оператор сложения интервалов;
* Оператор сложения интервала и момента и наоборот;


=================================================================================

Спец площадка: (зона с последовательным доступом)

Данные:
* Id;
* интервалы занимания площадки:
	Словарь, где ключ — начальный момент, значение — конечный момент;


Методы:
* Метод расчета интервала между начальными точками интервалов:


* Метод расчета интервала для безопасного слияния: (1)
	1) Получаем два интервала. 
	2) Вычисляем модуль разности между начальными моментами этих инетрвалов;
	3) Если полученная разность >= интервалу для безопасного слияния => возвращаем ноль;
	4) Если нет => возвращаем интервал для безопасного слияния = константное значение
		интервала для безопасного слияния - рассчитанная разность;

* Метод выделения интервала в конце списка (в Спец площадку записываем инетрвалы, сформированные моментами прибытия и покидания):
	Возвращаем интервал ожидания = разности момента покидания площадки последним 
	записанным судном и момента прибытия (без задержки) обратившегося судна и интервал для безопасного слияния = возврату метода расчета интервала между начальными точками интервалов;

* Метод, возвращающий задержку для ожидания обработки и для безопасного слияния (в кортеже):
	1) Создаем интервал занимания обратившегося судна из переданных им данных;
	2) Получаем ключи левого и правого интервала для словаря интервалов (метод (1) ЗПД) относительно созданного инетрвала;
	3) Проверяем пересечение созданного интервала с левым и правым (метод (2) ЗПД):
		3.1) Если пересечений нет => 
			3.1.1) Вызываем метод (1) для текущего и левого и текущего и правого интервалов;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			Если есть => возвращаем два нуля;
			Если нет => определяем, с каким интервалом, левым или правым, идет конфликт:
				Если с правым => возвращаем значение метода выделения интервала в конце списка; 
				Если с левым => сдвигаем интервал ВС вправо на минимально необходимый интервал для разрешения конфликта. Снова проверяем наличие безопасных интервалов между моментами прибытия:
					Если есть => проверяем пересечение интервалов:
						Если есть пересечение => возвращаем значение метода выделения интервала в конце списка;
						Если нет => возвращаем интервал ожидания обработки = 0 и интервал для безопасного слияния = величине сдвига интервала вправо;
					Если нет => возвращаем значение метода выделения интервала в конце списка;
		Если пересечения есть => возвращаем значение метода выделения интервала в конце списка;
* Метод сдвига интервала;
* Метод регистрации ВС:
	Получаем от ВС его Id, момент прихода и момент освобождения... 


ВПП: (зона с последовательным доступом) =======================================

Определение занятости: 1) в момент, когда взлетающее судно ушло с предварительного старта, рассчитываем момент освобождения ВПП этим судном, 2) если момент освобождения ВПП взлетающим судном раньше момента посадки садящегося судна, то разрешается взлет.

Данные:
* Id;
* интервалы занимания ВПП (когда ВПП станет занята);
	Словарь, где ключ — начальный момент, значение — конечный момент;

Методы:
* Возвращающий минимальное время ожидания на ПРСТ (которое можно отработать с неработающими двигателями):
	К нам обращается ВС и передает момент его выхода на исполнительный старт (момент занимания ВПП) и момент взлета (момент освобождения ВПП). Проверяем пересечение полученного интервала с записанными в ВПП интервалами (метод (2) ЗПД). Если пересечений нет => возвращаем ноль. Если есть => возвращаем значение метода выделения интервала в конце списка;


===============================================================================

Зона с последовательным доступом (ЗПД): 

Методы:
* Определяющий пересечение интервалов: (2)
	1) Создаем интервал обратившегося судна из переданных им данных;
	2) Вызываем метод (1), передаем ему созданный интервал. Получаем начальные моменты левого и правого интервала;
	3) Если начальный момент текущего интервала меньше конечного момента левого интервала => пересечение;
	4) Если конечный момент текущего интервала больше начального момента правого интервала => пересечение;
	5) Если ни то и ни другое => нет пересечения;

* Метод, находящий ближайшие моменты прибытия слева и справа относительно момента прибытия обратившегося судна: (1)
	1) Получаем интервал обратившегося судна; 
	2) Локально получаем список ключей словаря из полей класса;
	3) Добавляем в список начальный момент полученного интервала;
	4) Сортируем список;
	5) Получаем начальные моменты (по сути ключи словаря) левого и правого интервала;
	6) Взвращаем эти моменты;


===============================================================================

Генератор ВС:

Данные:
* 

Методы:
* Метод создания ВС (возвращает объект ВС);
* Метод выборки исходный данных для создания ВС;


===============================================================================

Неявная общая сущность: 
Данные:
* 
* рандомайзер (вроде не нужен, интервал нам задают);
* таймеры (вроде бы нужны для каждой стоянки);

Методы:
* Работа с новым ВС: (1) (вызывается методом, обрабатыващим срабатывание обоих таймеров)
	
* Вырабатывающий появление нового ВС (вызывается по таймеру соответствующей стоянки);

	
* Метод рассчета интервала между двумя моментами;

============================================================================

Таблица:
Данные:
* TableLayoutPanel как графическая основа;
* Двумерный массив как хранилище значений;

Методы:
* Добавление строки;
* Удаление строки;
* Вставка строки;
* Изменение значения ячейки;
* Расчет индекса контрола в коллекции контролов tableLayoutPanel;
* 


============================================================================

Класс-контроллер реализуемости планового момента выхода:

Синглтон. 

Данные:
* 

Методы:
* Метод проверки реализуемости без ПОО;
* Метод проверки реализуемости с ПОО;





Алгоритм рассчета индекса контрола в коллекции контролов tableLayoutPanel:
1) определяем, с какого последовательного индекса начинается данная строка = длина строки * индекс строки;
2) прибавляем к полученному начальному индексу индекс столбца;